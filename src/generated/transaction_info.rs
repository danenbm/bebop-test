//
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.4.6
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[derive(Clone, Debug, PartialEq, Default)]
pub struct TransactionInfo<'raw> {
    /// Field 1
    pub is_vote: ::core::option::Option<bool>,
    /// Field 2
    pub account_keys: ::core::option::Option<::std::vec::Vec<Pubkey<'raw>>>,
    /// Field 3
    pub log_messages: ::core::option::Option<::std::vec::Vec<&'raw str>>,
    /// Field 4
    pub inner_instructions: ::core::option::Option<::std::vec::Vec<InnerInstructions<'raw>>>,
    /// Field 5
    pub outer_instructions: ::core::option::Option<::std::vec::Vec<CompiledInstruction<'raw>>>,
    /// Field 6
    pub slot: ::core::option::Option<u64>,
    /// Field 7
    pub slot_index: ::core::option::Option<&'raw str>,
    /// Field 8
    pub seen_at: ::core::option::Option<i64>,
}

impl<'raw> ::bebop::SubRecord<'raw> for TransactionInfo<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + self
                .is_vote
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .account_keys
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .log_messages
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .inner_instructions
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .outer_instructions
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .slot
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .slot_index
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .seen_at
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
    }

    #[allow(unaligned_references)]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = self.is_vote {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.account_keys {
            2u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.log_messages {
            3u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.inner_instructions {
            4u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.outer_instructions {
            5u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.slot {
            6u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.slot_index {
            7u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.seen_at {
            8u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _is_vote = None;
        let mut _account_keys = None;
        let mut _log_messages = None;
        let mut _inner_instructions = None;
        let mut _outer_instructions = None;
        let mut _slot = None;
        let mut _slot_index = None;
        let mut _seen_at = None;

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _is_vote.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _is_vote = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _account_keys.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _account_keys = Some(value)
                }
                3 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _log_messages.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _log_messages = Some(value)
                }
                4 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _inner_instructions.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _inner_instructions = Some(value)
                }
                5 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _outer_instructions.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _outer_instructions = Some(value)
                }
                6 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _slot.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _slot = Some(value)
                }
                7 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _slot_index.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _slot_index = Some(value)
                }
                8 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _seen_at.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _seen_at = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        Ok((
            i,
            Self {
                is_vote: _is_vote,
                account_keys: _account_keys,
                log_messages: _log_messages,
                inner_instructions: _inner_instructions,
                outer_instructions: _outer_instructions,
                slot: _slot,
                slot_index: _slot_index,
                seen_at: _seen_at,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for TransactionInfo<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Pubkey<'raw> {
    pub key: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Pubkey<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.key.serialized_size()
    }

    #[allow(unaligned_references)]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.key._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { key: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Pubkey<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct InnerInstructions<'raw> {
    pub index: u8,
    pub instructions: ::std::vec::Vec<CompiledInstruction<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for InnerInstructions<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <u8>::MIN_SERIALIZED_SIZE
        + <::std::vec::Vec<CompiledInstruction<'raw>>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.index.serialized_size() + self.instructions.serialized_size()
    }

    #[allow(unaligned_references)]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.index._serialize_chained(dest)? + self.instructions._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                index: v0,
                instructions: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for InnerInstructions<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct CompiledInstruction<'raw> {
    pub program_id_index: u8,
    pub accounts: ::bebop::SliceWrapper<'raw, u8>,
    pub data: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for CompiledInstruction<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <u8>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.program_id_index.serialized_size()
            + self.accounts.serialized_size()
            + self.data.serialized_size()
    }

    #[allow(unaligned_references)]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.program_id_index._serialize_chained(dest)?
            + self.accounts._serialize_chained(dest)?
            + self.data._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                program_id_index: v0,
                accounts: v1,
                data: v2,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for CompiledInstruction<'raw> {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TransactionInfo {
        /// Field 1
        pub is_vote: ::core::option::Option<bool>,
        /// Field 2
        pub account_keys: ::core::option::Option<::std::vec::Vec<Pubkey>>,
        /// Field 3
        pub log_messages: ::core::option::Option<::std::vec::Vec<String>>,
        /// Field 4
        pub inner_instructions: ::core::option::Option<::std::vec::Vec<InnerInstructions>>,
        /// Field 5
        pub outer_instructions: ::core::option::Option<::std::vec::Vec<CompiledInstruction>>,
        /// Field 6
        pub slot: ::core::option::Option<u64>,
        /// Field 7
        pub slot_index: ::core::option::Option<String>,
        /// Field 8
        pub seen_at: ::core::option::Option<i64>,
    }

    impl<'raw> ::core::convert::From<super::TransactionInfo<'raw>> for TransactionInfo {
        fn from(value: super::TransactionInfo) -> Self {
            Self {
                is_vote: value.is_vote,
                account_keys: value
                    .account_keys
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
                log_messages: value
                    .log_messages
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
                inner_instructions: value
                    .inner_instructions
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
                outer_instructions: value
                    .outer_instructions
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
                slot: value.slot,
                slot_index: value.slot_index.map(|value| value.into()),
                seen_at: value.seen_at,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for TransactionInfo {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + self
                    .is_vote
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .account_keys
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .log_messages
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .inner_instructions
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .outer_instructions
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .slot
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .slot_index
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .seen_at
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
        }

        #[allow(unaligned_references)]
        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = self.is_vote {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.account_keys {
                2u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.log_messages {
                3u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.inner_instructions {
                4u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.outer_instructions {
                5u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.slot {
                6u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.slot_index {
                7u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.seen_at {
                8u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _is_vote = None;
            let mut _account_keys = None;
            let mut _log_messages = None;
            let mut _inner_instructions = None;
            let mut _outer_instructions = None;
            let mut _slot = None;
            let mut _slot_index = None;
            let mut _seen_at = None;

            #[cfg(not(feature = "unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _is_vote.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _is_vote = Some(value)
                    }
                    2 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _account_keys.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _account_keys = Some(value)
                    }
                    3 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _log_messages.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _log_messages = Some(value)
                    }
                    4 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _inner_instructions.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _inner_instructions = Some(value)
                    }
                    5 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _outer_instructions.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _outer_instructions = Some(value)
                    }
                    6 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _slot.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _slot = Some(value)
                    }
                    7 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _slot_index.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _slot_index = Some(value)
                    }
                    8 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _seen_at.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _seen_at = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            Ok((
                i,
                Self {
                    is_vote: _is_vote,
                    account_keys: _account_keys,
                    log_messages: _log_messages,
                    inner_instructions: _inner_instructions,
                    outer_instructions: _outer_instructions,
                    slot: _slot,
                    slot_index: _slot_index,
                    seen_at: _seen_at,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for TransactionInfo {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Pubkey {
        pub key: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::Pubkey<'raw>> for Pubkey {
        fn from(value: super::Pubkey) -> Self {
            Self {
                key: value.key.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Pubkey {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.key.serialized_size()
        }

        #[allow(unaligned_references)]
        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.key._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self { key: v0 }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Pubkey {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct InnerInstructions {
        pub index: u8,
        pub instructions: ::std::vec::Vec<CompiledInstruction>,
    }

    impl<'raw> ::core::convert::From<super::InnerInstructions<'raw>> for InnerInstructions {
        fn from(value: super::InnerInstructions) -> Self {
            Self {
                index: value.index,
                instructions: value
                    .instructions
                    .into_iter()
                    .map(|value| value.into())
                    .collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for InnerInstructions {
        const MIN_SERIALIZED_SIZE: usize =
            <u8>::MIN_SERIALIZED_SIZE + <::std::vec::Vec<CompiledInstruction>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.index.serialized_size() + self.instructions.serialized_size()
        }

        #[allow(unaligned_references)]
        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(
                self.index._serialize_chained(dest)?
                    + self.instructions._serialize_chained(dest)?,
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    index: v0,
                    instructions: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for InnerInstructions {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct CompiledInstruction {
        pub program_id_index: u8,
        pub accounts: ::std::vec::Vec<u8>,
        pub data: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::CompiledInstruction<'raw>> for CompiledInstruction {
        fn from(value: super::CompiledInstruction) -> Self {
            Self {
                program_id_index: value.program_id_index,
                accounts: value.accounts.iter().map(|value| value).collect(),
                data: value.data.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for CompiledInstruction {
        const MIN_SERIALIZED_SIZE: usize = <u8>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.program_id_index.serialized_size()
                + self.accounts.serialized_size()
                + self.data.serialized_size()
        }

        #[allow(unaligned_references)]
        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.program_id_index._serialize_chained(dest)?
                + self.accounts._serialize_chained(dest)?
                + self.data._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    program_id_index: v0,
                    accounts: v1,
                    data: v2,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for CompiledInstruction {}
}
